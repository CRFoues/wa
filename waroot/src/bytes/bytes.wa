// 版权 @2023 凹语言 作者。保留所有权利。

// Equal reports whether a and b
// are the same length and contain the same bytes.
// A nil argument is equivalent to an empty slice.
func Equal(a, b: []byte) => bool {
	// Neither cmd/compile nor gccgo allocates for these string conversions.
	return string(a) == string(b)
}

// 忽略英文大小写比较
func EqualFold(s, t: []byte) => bool {
	if len(s) != len(t) {
		return false
	}
	if len(s) == 0 {
		return true
	}
	for i := 0; i < len(s); i++ {
		if toupper(s[i]) != toupper(t[i]) {
			return false
		}
	}
	return true
}

func Index(d: []byte, x: []byte) => int {
	return 0
}

func IndexByte(b: []byte, c: byte) => int {
	for i := 0; i < len(b); i++ {
		if b[i] == c {
			return i
		}
	}
	return -1
}

func IndexByteString(s: string, c: byte) => int {
	// TODO(chai2010): 字符串 range 尚不支持
	//for i := 0; i < len(s); i++ {
	//	if s[i] == c {
	//		return i
	//	}
	//}
	return -1
}

func HasPrefix(d, prefix: []byte) => bool {
	return false
}

func HasSuffix(d, suffix: []byte) => bool {
	return false
}

func toupper(c: byte) => byte {
	if c >= 'a' && c <= 'z' {
		return c - 32
	}
	return c
}

func tolower(c: byte) => byte {
	if c >= 'A' && c <= 'Z' {
		return c + 32
	}
	return c
}

// Repeat returns a new byte slice consisting of count copies of b.
//
// It panics if count is negative or if
// the result of (len(b) * count) overflows.
func Repeat(b: []byte, count: int) => []byte {
	if count == 0 {
		return []byte{}
	}
	// Since we cannot return an error on overflow,
	// we should panic if the repeat will generate
	// an overflow.
	// See Issue golang.org/issue/16237.
	if count < 0 {
		panic("bytes: negative Repeat count")
	} else if len(b)*count/count != len(b) {
		panic("bytes: Repeat count causes overflow")
	}

	nb := make([]byte, len(b)*count)
	bp := copy(nb, b)
	for bp < len(nb) {
		copy(nb[bp:], nb[:bp])
		bp *= 2
	}
	return nb
}
